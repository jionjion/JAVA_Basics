# 设计模式

## 核心原则

### 单一职责
一个类/方法只负责一个职责.

### 接口隔离
客户端不应该依赖它不需要的接口; 
如:当一个接口定义过多方法时,其调用者们可能不会用到全部方法,则需要将一个大接口按照方法进行分组拆分为多个小接口,以便降低隔离.

### 依赖倒转
1. 高层模块不应该依赖低层模块,二者都因该依赖 **抽象** .
2. 抽象不应该依赖细节,细节应该依赖抽象.如:在Service层依赖Dao层接口,而非实现.
3. 依赖倒转的中心思想是 **面向接口编程** .如:声明接口及其实现,通过调用接口而非实现.
4. 抽象比具体更稳固,代码变动少.
5. 使用接口/抽象制定规范,而不涉及到具体的任何操作.

依赖传递:
- 接口传递:在调用处传递接口作为方法参数.
- 构造方法传递:在构造方法中,传递接口作为构造参数
- setter方法传递:调用setter方法,传递接口作为类的成员变量

### 里式替换
在子类中尽量不要重写父类方法;
而是通过抽取相同类的共有方法提取到父类,通过组合(component),实现调用相同类之间的依赖

### 开闭原则
1. 对扩展放开发(提供方),对使修改关闭(调用方).
2. 当软件变化时,通过扩展软件而实现变化,而不是修改原有代码.
如: 接口定义和具体的实现类.

### 迪米特法则/
一个类对自己依赖的类知道的越少越好.即:将内部逻辑封装,对外提供(public)方法

### 合成复用
尽量使用组合/聚合的方式,而不是继承方式
组合: 强制依赖的类关系.
聚合: 松依赖的类关系.

## 设计模式分类
- 创建型
单例模式 / 工厂模式 / 抽象工厂模式 / 原型模式 / 建造者模式
- 结构型
适配器模式 / 桥接模式 / 装饰器模式 / 组合模式 / 外观模式 / 享元模式 / 代理模式
- 行为型
模板方法模式 / 命令模式 / 访问者模式 / 迭代器模式 / 观察者模式 / 中介者模式 / 备忘录模式 / 解释器模式 / 状态模式 / 策略模式 / 责任链模式

## 设计模式解决问题
单例模式:
唯一实例创建问题

工厂模式:
同一基类,不同实现类的创建问题

抽象工厂模式:
相似基类,不同实现类的创建问题

原型模式:
对象克隆创建问题

建造者模式:
将繁琐的对象创建过程拆分

适配器模式:
不同类和方法间调用问题

桥接模式:
类多继承导致类数量爆炸问题

装饰器模式:
动态地将新功能添加到新对象上,解决多实例间组合问题

组合模式:
处理的对象具有树形结构,且叶子与枝杈具有相似的方法属性.

外观模式:
通过组合以屏蔽子系统细节,使得调用只跟接口发生,无关子系统内部.

享元模式:
解决重复对象的内存浪费问题,共享相同的对象,常用作连接池

代理模式:
为对象提供一个代理,通过该代理完成对象的调用,以期增强其特性,而无需修改原有代码

模板模式:
为了完成某个过程,需要一系列步骤,但是稍有不同的问题

命令模式:
将请求发送与接收动作相解耦,无需关注相互细节

访问者模式:
在系统中有一个稳定的数据结构,但有经常变化的功能需求.

迭代器模式:
提供统一的迭代器完成遍历,而不用暴露内部数据结构.

观察者模式:
当一方变化时,通知多方观察者.

中介者模式:
用一个中介者封装一系列的对象交互,中介者使对象之间无需重复交互引用.

备忘录模式:
提供一个可以恢复对象状态的机制

解释器模式:
对自定义语言进行解释执行

状态模式:
对象多种状态间转换时,对外输出不同的执行

策略模式:
通过定义算法族,分别封装,以便相互替换.

责任链模式:
为请求创建一个接受请求的链.
