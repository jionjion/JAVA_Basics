# 并发流程控制

## 并发任务控制器
默认系统自行控制, 也可以自行控制

Semaphore
信号量, 可以通过控制“许可证”的数量,来保证线程之间的配合
线程只有在拿到“许可证"后才能继续运行。相比于其他的同步器, 更灵活

CyclicBarrier
线程会等待, 直到足够多线程达到了事先规定的数目, 一旦达到触发条件,
就可以进行下一步的动作.

适用于线程之间相互等待处理结果就绪的场景

Phaser
和CyclicBarrier类似, 但是的计数可变
Java 7加入

CountDownLatch
和CyclicBarrier类似, 数量递减到0时, 触发动作
不可重复使用

Exchanger
让两个线程在合适时交换对象
适用当两个线程工作在同一个类的不同实例上时, 用于交换数据

Condition
可以控制线程的 “等待” 和 "唤醒"
是 `Object.wait()` 的升级版

## CountDownLatch 类
倒数门栓, 并发流程控制工具
例如: 拼团购物; 购票,人满发车..
流程: 倒数结束之前, 一直处于等待状态, 直到倒计时结束, 线程才继续工作

CountDownLatch(int count) 构造函数,count 为需要倒数的值
await() ,调用后线程会挂起, 直到count为0后才会继续执行
countDown(), 将 count 值减1, 当 count 为 0 时, 线程会被唤起..

用法1: 一个主线程等待多个线程执行完毕后, 再继续主线程的工作
用法2: 多个线程等待一个线程的信号, 同时开始执行. 

