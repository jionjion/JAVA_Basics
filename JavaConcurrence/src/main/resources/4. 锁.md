# 锁
## Lock 接口
锁是一种工具, 用于控制共享资源的访问

ReentrantLock 

synchronized 
1. 效率低, 释放情况少(1.代码完全执行完成;2.抛出异常)
2. 获得锁的动作不能设定超时
3. 无法知道是否成功获得锁, 在尚未获取锁之前会一直等待...

Lock 接口
`lock`                      获取锁, 如果当前锁已经被其他线程获取, 则等待; Lock 不会像 synchronized 那样在发生异常时解锁, 因此一定要在 finally 中释放
`tryLock`                   尝试获取锁, 可以设置超时时间, 如果依然没有拿到锁, 返回 false!
`lockInterruptibly`         相当于在尝试获取锁时将超时时间设置为无线,在等待锁的过程中, 可以被打断,抛出 InterruptedException 异常
`unlock`                    解锁, 一定要写在 finally 语句中, 千万不要忘记释放锁

## 标准用法
标准写法,在锁后必须跟上try执行业务逻辑和finally释放锁
```
// 上锁
lock.lock();
// try 需要被独占的资源
try {
    System.out.println("业务逻辑.....");
} finally {
    // 必须释放锁 
    lock.unlock();
}
```

## 可见性
线程与线程之间数据的状态,保证不同线程之间可以看到对方的数据发生修改

> happens-before 原则: 我们这件事发生了, 别的线程能看到发生的事件, 知晓修改的内容;

Lock 和 synchronized 具有相同语义, 可以保证下一个线程在加锁后可以看到所有前一个线程解锁前发生的所有操作. 


## 锁的分类
| 说明                | 锁                         | 示例         |
|-------------------|---------------------------|------------|
| 线程要不要锁住同步资源       | 锁住/悲观锁                    | for update |
| 多线程能否共享一把锁        | 共享锁/独占锁                   | 读写锁        |
| 多线程竞争时，是否排队       | 排队公平锁/非公平锁(先尝试插队，插队失败再排队) |            |
| 同一个线程是否可以重复获取同一把锁 | 可以可重入/不可重入锁               |            |
| 可以可中断锁            | 可中断锁/非可中断锁                |            |
| 等锁的过程             | 自旋锁(自旋,尝试获取锁)/非自旋锁(阻塞)    |            |

### 乐观锁与悲观锁
非互斥同步锁/互斥同步锁

#### 悲观锁/互斥同步锁
1. 阻塞和唤醒带来性能问题
2. 可能陷入永久阻塞
3. 优先级低的线程拿到锁后会影响优先级错乱 

在执行阶段,对资源进行锁定,等完成操作后再释放;避免多个线程间同时操作 
`synchronized` 和 `Lock` 相关类

适合并发写入多的情况,临界区持锁时间长的情况,悲观锁可以避免大量无用的自旋消耗,典型情况有
- 临界区内有 `IO` 操作
- 临界区代码复杂, 循环多
- 临界区内竞争激烈

#### 乐观锁/非互斥同步锁
在执行的时候不会发生锁,之后在最后更新阶段,会判断在此期间是否发生修改,未被修改则会更新;否则就丢弃/重试/报错..
原子类和并发容器.. 

CAS算法, 在一个原子操作内完成对比和操作

适合并发写入少的情况,大部分情况是读取的场景,无需加锁就可以提高性能

### 可重入锁
ReentrantLock 可重入锁, 当前线程拿到锁后, 无需再次获取锁就可以持有, 线程可以多次获得同一把锁;
如, 在A方法中, 拿到锁后, 继续执行; 在B方法中, 需要同一个锁..由于已经获得当前锁,所以可以继续持有继续使用, 无需重复再次排队获取锁; 
- 避免了因为多次尝试获取同一把锁导致的线程死锁
- 同时提高的代码的封装

#### 常用方法
isHeldByCurrentThread  当前线程是否被当前线程持有
getQueueLength 等待当前锁的队列有多长
getHoldCount 当前锁已经被拿了几次

