# 锁
## Lock 接口
锁是一种工具, 用于控制共享资源的访问

ReentrantLock 

synchronized 
1. 效率低, 释放情况少(1.代码完全执行完成;2.抛出异常)
2. 获得锁的动作不能设定超时
3. 无法知道是否成功获得锁, 在尚未获取锁之前会一直等待...

Lock 接口
`lock`                      获取锁, 如果当前锁已经被其他线程获取, 则等待; Lock 不会像 synchronized 那样在发生异常时解锁, 因此一定要在 finally 中释放
`tryLock`                   尝试获取锁, 可以设置超时时间, 如果依然没有拿到锁, 返回 false!
`lockInterruptibly`         相当于在尝试获取锁时将超时时间设置为无线,在等待锁的过程中, 可以被打断,抛出 InterruptedException 异常
`unlock`                    解锁, 一定要写在 finally 语句中, 千万不要忘记释放锁

## 标准用法
标准写法,在锁后必须跟上try执行业务逻辑和finally释放锁
```
// 上锁
lock.lock();
// try 需要被独占的资源
try {
    System.out.println("业务逻辑.....");
} finally {
    // 必须释放锁 
    lock.unlock();
}
```

## 可见性
线程与线程之间数据的状态,保证不同线程之间可以看到对方的数据发生修改

> happens-before 原则: 我们这件事发生了, 别的线程能看到发生的事件, 知晓修改的内容;

Lock 和 synchronized 具有相同语义, 可以保证下一个线程在加锁后可以看到所有前一个线程解锁前发生的所有操作. 


## 锁的分类
| 说明                | 锁                         | 示例         |
|-------------------|---------------------------|------------|
| 线程要不要锁住同步资源       | 锁住/悲观锁                    | for update |
| 多线程能否共享一把锁        | 共享锁/独占锁                   | 读写锁        |
| 多线程竞争时，是否排队       | 排队公平锁/非公平锁(先尝试插队，插队失败再排队) |            |
| 同一个线程是否可以重复获取同一把锁 | 可以可重入/不可重入锁               |            |
| 可以可中断锁            | 可中断锁/非可中断锁                |            |
| 等锁的过程             | 自旋锁(自旋,尝试获取锁)/非自旋锁(阻塞)    |            |

### 乐观锁与悲观锁
非互斥同步锁/互斥同步锁

#### 悲观锁/互斥同步锁
1. 阻塞和唤醒带来性能问题
2. 可能陷入永久阻塞
3. 优先级低的线程拿到锁后会影响优先级错乱 

在执行阶段,对资源进行锁定,等完成操作后再释放;避免多个线程间同时操作 
`synchronized` 和 `Lock` 相关类

适合并发写入多的情况,临界区持锁时间长的情况,悲观锁可以避免大量无用的自旋消耗,典型情况有
- 临界区内有 `IO` 操作
- 临界区代码复杂, 循环多
- 临界区内竞争激烈

#### 乐观锁/非互斥同步锁
在执行的时候不会发生锁,之后在最后更新阶段,会判断在此期间是否发生修改,未被修改则会更新;否则就丢弃/重试/报错..
原子类和并发容器.. 

CAS算法, 在一个原子操作内完成对比和操作

适合并发写入少的情况,大部分情况是读取的场景,无需加锁就可以提高性能

### 可重入锁
ReentrantLock 可重入锁, 当前线程拿到锁后, 无需再次获取锁就可以持有, 线程可以多次获得同一把锁;
如, 在A方法中, 拿到锁后, 继续执行; 在B方法中, 需要同一个锁..由于已经获得当前锁,所以可以继续持有继续使用, 无需重复再次排队获取锁; 
- 避免了因为多次尝试获取同一把锁导致的线程死锁
- 同时提高的代码的封装

#### 常用方法
isHeldByCurrentThread  当前线程是否被当前线程持有
getQueueLength 等待当前锁的队列有多长
getHoldCount 当前锁已经被拿了几次

### 公平锁/非公平锁
公平指: 按照线程请求的顺序, 来分配锁
非公平: 不完全按照请求的顺序, 在一定情况下, 可以插队(一般是短时任务,在唤醒期间可以执行)
这样可以避免唤醒带来的空档期

ReentrantLock 默认创建时,构造参数可以确定, 默认不公平锁
`true` 为公平锁; `false` 非公平锁

公平锁:
优先:各线程公平平等，每个线程在等待一段时间后，总有执行的机会
劣势:更慢，吞吐量更小

不公平锁:
优势:更快，吞吐量更大
劣势:有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行

`tryLock()` 方法,自带插队属性,如果尝试获取拿到了锁, 就可以插队执行

#### 共享锁和排它锁
排它锁: 独占锁/独享锁, 在锁后只能当前线程进行操作
共享锁: 读锁, 无法修改和删除数据库,只能查看

ReentrantReadWriteLock 读写锁.读的时候,不上锁; 写的时候,上锁

共享规则
- 多个线程只申请读锁，都可以申请到
- 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。
- 如果有一个线程已经占用了写钞 员，则此时其他线程如果申请写锁或 者读锁，则申请的线程会一直等待释放写锁。
- 一句话总结:要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出丑(要么多读，要多一写)

读写锁的规则
读写锁只是一把锁，可以通过两种方式锁定
读锁定和写锁定。读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定
多读一写

#### 排队策略
公平锁: 不许用插队
非公平: 写锁可以插队, 跑到读锁前面..  
读锁仅在等待队列头节不是想要获取写锁的线程的时候可以插队

#### 锁的降级
ReentrantReadWriteLock 只支持降级, 不支持升级(避免死锁)
适合读多写少的情况, 进一步提高并发效率

### 自旋和阻塞锁
阻塞或者唤醒一个线程需要操作系统切换CPU状态来完成, 这种状态的转换需要消耗处理器时间..

如果同步代码块中的内容过于简单, 状态转换消耗的时间有可能比用户代码执行的时间还要长
在许多场景中, 同步资源的锁定时间很短, 为了这一小段时间去切换线程, 线程挂起和恢复现场的花费可能会让系统得不偿失

#### 自旋
如果物理机器有多个处理器, 能够让两个或以上的线程同时并行执行, 我们就可以让后面那个请求锁的线程不放弃CPU的执行时间, 看看持有锁的线程是否很快就会释放锁 而为了让当前线程“稍等一下” 
我们需让当前线程进行自旋, 如果在自旋完成后前面锁定同步资源的线程已经释放了锁, 那么当前线程就可以不必阻塞而是直接获取同步资源, 从而避免切换线程的开销。

阻塞锁和自旋锁相反, 阻塞锁如果遇到没拿到锁的情况, 会直接把线程阻塞, 直到被唤醒

默认的并发框架 java.util.concurrent.atmoic 包通过自旋实现

#### 适用场景
自旋锁一般用于多核的服务器, 在并发度不是特别高的情况下, 比阻塞锁的效率高
另外, 自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后 才会释放），那也是不合适的


### 可中断锁
在Java中，`synchronized` 就不是可中断锁，
Lock是可中断锁, `tryLock(time)` 和 `lockInterrupiptibly` 都能响应中断

如果某一线程A正在执行锁中的代码, 另一线程B正在等待获取该锁可能由于等待时间过长, 线程B不想等待了, 想先处理其他事情, 我们可以中断它, 这种就是可中断锁


### Java 虚拟机对锁的优化
自旋锁和自适应:
如果自旋锁的时间过长,自动转为阻塞锁

消除锁:
如果不需要加锁的地方,自动取消锁

锁粗化:
一系列重复的加锁解锁进行整体优化, 统一粗化

1. 缩小同步代码块
2. 不要锁住方法, 而是锁住具体的执行逻辑
3. 减少请求锁的次数
4. 锁中不要再包含锁
5. 选择合适的锁类型或者合适的工具类