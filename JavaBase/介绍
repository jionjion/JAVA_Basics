并发:程序有多个线程,同时一个程序以不同状态执行时.
	多个线程操作相同的资源,保证线程安全
高并发:
	短时间内收到很多请求,提高程序性能
	
缓存一致性

java内存模型
	lock 	锁定,作用在主内存的变量,把一个变量标识为线程独占状态
	unlock	解锁,作用在主内存的变量,把一个变量释放,释放后的变量可以被其他线程锁定
	read	读取,作用在主内存的变量,把一个变量从主内存传输到线程的工作内存中,以便随后的load动作
	load	载入,作用在工作内存的变量,把read从主内存中得到的变量放到工作内存的变量副本中
	use		使用,作用在工作内存的变量,把工作内存中的一个变量值传递给执行引擎
	assign	赋值,作用在工作内存的变量,把一个从执行引擎中收到的值赋值给工作内存变量
	store	储存,作用在工作内存的变量,把工作内存中的一个变量的值传送到主内存中,以便随后的write的操作
	write	写入,作用在主内存的变量,把store从工作内存中得到的变量传递到主内存的变量中
	
同步规则
	- 如果把一个变量从主内存中复制到工作内存,就需要按顺序地执行read和load操作,如果把变量从工作内存中同步回主内存中,就要按顺序地执行
		stroe和write操作.但Java内存模型只要求上述操作必须顺序执行,而没有保证必须是连续执行.
	- 不允许read和load,store和write操作之一单独出现
	- 不允许一个线程丢弃它的最近assign的操作,即变量在工作内存中改变之后必须同步到主内存中
	- 不允许一个线程无原因,在未发生assign操作下,将数据从内存空间同步到主内存中
	- 一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化(load或assign)的变量.
		即在对一个变量执行use和store之前,必须执行了load和assign操作
	- 一个变量在同一时刻只允许一个线程对其进行lock操作,但lock操作可以被同一线程重复执行多次,多次lock之后,只有执行相同次数的unlock
		操作,变量才会被解锁.lock和unlock必须成对出现
	- 如果一个变量执行lock操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量之前需要重新执行load或者assign操作初始化变量的值
	- 如果一个变量事先没有被lock操作锁定,则不允许对它执行unlock操作;也不允许unlock一个被其他线程锁定的变量
	- 对一个变量执行unlock操作之前,必须先把此变量同步到主内存中,执行store和write操作
	
	
	
	
	
	
	
	
	